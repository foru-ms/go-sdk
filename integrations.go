// Code generated by Fern. DO NOT EDIT.

package foru_ms_sdk

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/foru-ms/go-sdk/internal"
	big "math/big"
)

var (
	createIntegrationsRequestFieldType         = big.NewInt(1 << 0)
	createIntegrationsRequestFieldName         = big.NewInt(1 << 1)
	createIntegrationsRequestFieldConfig       = big.NewInt(1 << 2)
	createIntegrationsRequestFieldActive       = big.NewInt(1 << 3)
	createIntegrationsRequestFieldExtendedData = big.NewInt(1 << 4)
)

type CreateIntegrationsRequest struct {
	// Integration type (e.g. SLACK, DISCORD)
	Type string `json:"type" url:"-"`
	// Integration name
	Name string `json:"name" url:"-"`
	// JSON configuration
	Config map[string]interface{} `json:"config,omitempty" url:"-"`
	// Whether integration is active
	Active *bool `json:"active,omitempty" url:"-"`
	// Custom extended data
	ExtendedData map[string]interface{} `json:"extendedData,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CreateIntegrationsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateIntegrationsRequest) SetType(type_ string) {
	c.Type = type_
	c.require(createIntegrationsRequestFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateIntegrationsRequest) SetName(name string) {
	c.Name = name
	c.require(createIntegrationsRequestFieldName)
}

// SetConfig sets the Config field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateIntegrationsRequest) SetConfig(config map[string]interface{}) {
	c.Config = config
	c.require(createIntegrationsRequestFieldConfig)
}

// SetActive sets the Active field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateIntegrationsRequest) SetActive(active *bool) {
	c.Active = active
	c.require(createIntegrationsRequestFieldActive)
}

// SetExtendedData sets the ExtendedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateIntegrationsRequest) SetExtendedData(extendedData map[string]interface{}) {
	c.ExtendedData = extendedData
	c.require(createIntegrationsRequestFieldExtendedData)
}

var (
	deleteIntegrationsRequestFieldID = big.NewInt(1 << 0)
)

type DeleteIntegrationsRequest struct {
	// Integration ID
	ID string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (d *DeleteIntegrationsRequest) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteIntegrationsRequest) SetID(id string) {
	d.ID = id
	d.require(deleteIntegrationsRequestFieldID)
}

var (
	listIntegrationsRequestFieldLimit  = big.NewInt(1 << 0)
	listIntegrationsRequestFieldCursor = big.NewInt(1 << 1)
)

type ListIntegrationsRequest struct {
	// Items per page (max 75)
	Limit *int `json:"-" url:"limit,omitempty"`
	// Cursor for pagination
	Cursor *string `json:"-" url:"cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (l *ListIntegrationsRequest) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListIntegrationsRequest) SetLimit(limit *int) {
	l.Limit = limit
	l.require(listIntegrationsRequestFieldLimit)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListIntegrationsRequest) SetCursor(cursor *string) {
	l.Cursor = cursor
	l.require(listIntegrationsRequestFieldCursor)
}

var (
	retrieveIntegrationsRequestFieldID = big.NewInt(1 << 0)
)

type RetrieveIntegrationsRequest struct {
	// Integration ID
	ID string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *RetrieveIntegrationsRequest) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrieveIntegrationsRequest) SetID(id string) {
	r.ID = id
	r.require(retrieveIntegrationsRequestFieldID)
}

var (
	integrationListResponseFieldData = big.NewInt(1 << 0)
)

type IntegrationListResponse struct {
	Data *IntegrationListResponseData `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IntegrationListResponse) GetData() *IntegrationListResponseData {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *IntegrationListResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationListResponse) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationListResponse) SetData(data *IntegrationListResponseData) {
	i.Data = data
	i.require(integrationListResponseFieldData)
}

func (i *IntegrationListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntegrationListResponse) MarshalJSON() ([]byte, error) {
	type embed IntegrationListResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IntegrationListResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	integrationListResponseDataFieldItems      = big.NewInt(1 << 0)
	integrationListResponseDataFieldNextCursor = big.NewInt(1 << 1)
	integrationListResponseDataFieldCount      = big.NewInt(1 << 2)
)

type IntegrationListResponseData struct {
	Items []*IntegrationListResponseDataItemsItem `json:"items" url:"items"`
	// Cursor for next page
	NextCursor *string `json:"nextCursor,omitempty" url:"nextCursor,omitempty"`
	// Total count of items
	Count int `json:"count" url:"count"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IntegrationListResponseData) GetItems() []*IntegrationListResponseDataItemsItem {
	if i == nil {
		return nil
	}
	return i.Items
}

func (i *IntegrationListResponseData) GetNextCursor() *string {
	if i == nil {
		return nil
	}
	return i.NextCursor
}

func (i *IntegrationListResponseData) GetCount() int {
	if i == nil {
		return 0
	}
	return i.Count
}

func (i *IntegrationListResponseData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationListResponseData) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetItems sets the Items field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationListResponseData) SetItems(items []*IntegrationListResponseDataItemsItem) {
	i.Items = items
	i.require(integrationListResponseDataFieldItems)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationListResponseData) SetNextCursor(nextCursor *string) {
	i.NextCursor = nextCursor
	i.require(integrationListResponseDataFieldNextCursor)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationListResponseData) SetCount(count int) {
	i.Count = count
	i.require(integrationListResponseDataFieldCount)
}

func (i *IntegrationListResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationListResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationListResponseData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntegrationListResponseData) MarshalJSON() ([]byte, error) {
	type embed IntegrationListResponseData
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IntegrationListResponseData) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	integrationListResponseDataItemsItemFieldID           = big.NewInt(1 << 0)
	integrationListResponseDataItemsItemFieldType         = big.NewInt(1 << 1)
	integrationListResponseDataItemsItemFieldName         = big.NewInt(1 << 2)
	integrationListResponseDataItemsItemFieldActive       = big.NewInt(1 << 3)
	integrationListResponseDataItemsItemFieldExtendedData = big.NewInt(1 << 4)
	integrationListResponseDataItemsItemFieldCreatedAt    = big.NewInt(1 << 5)
	integrationListResponseDataItemsItemFieldUpdatedAt    = big.NewInt(1 << 6)
)

type IntegrationListResponseDataItemsItem struct {
	ID string `json:"id" url:"id"`
	// Integration type
	Type IntegrationListResponseDataItemsItemType `json:"type" url:"type"`
	// Integration name
	Name string `json:"name" url:"name"`
	// Whether integration is active
	Active bool `json:"active" url:"active"`
	// Custom extended data
	ExtendedData map[string]interface{} `json:"extendedData,omitempty" url:"extendedData,omitempty"`
	// Integration creation timestamp
	CreatedAt string `json:"createdAt" url:"createdAt"`
	// Integration last update timestamp
	UpdatedAt string `json:"updatedAt" url:"updatedAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IntegrationListResponseDataItemsItem) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *IntegrationListResponseDataItemsItem) GetType() IntegrationListResponseDataItemsItemType {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *IntegrationListResponseDataItemsItem) GetName() string {
	if i == nil {
		return ""
	}
	return i.Name
}

func (i *IntegrationListResponseDataItemsItem) GetActive() bool {
	if i == nil {
		return false
	}
	return i.Active
}

func (i *IntegrationListResponseDataItemsItem) GetExtendedData() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.ExtendedData
}

func (i *IntegrationListResponseDataItemsItem) GetCreatedAt() string {
	if i == nil {
		return ""
	}
	return i.CreatedAt
}

func (i *IntegrationListResponseDataItemsItem) GetUpdatedAt() string {
	if i == nil {
		return ""
	}
	return i.UpdatedAt
}

func (i *IntegrationListResponseDataItemsItem) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationListResponseDataItemsItem) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationListResponseDataItemsItem) SetID(id string) {
	i.ID = id
	i.require(integrationListResponseDataItemsItemFieldID)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationListResponseDataItemsItem) SetType(type_ IntegrationListResponseDataItemsItemType) {
	i.Type = type_
	i.require(integrationListResponseDataItemsItemFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationListResponseDataItemsItem) SetName(name string) {
	i.Name = name
	i.require(integrationListResponseDataItemsItemFieldName)
}

// SetActive sets the Active field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationListResponseDataItemsItem) SetActive(active bool) {
	i.Active = active
	i.require(integrationListResponseDataItemsItemFieldActive)
}

// SetExtendedData sets the ExtendedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationListResponseDataItemsItem) SetExtendedData(extendedData map[string]interface{}) {
	i.ExtendedData = extendedData
	i.require(integrationListResponseDataItemsItemFieldExtendedData)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationListResponseDataItemsItem) SetCreatedAt(createdAt string) {
	i.CreatedAt = createdAt
	i.require(integrationListResponseDataItemsItemFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationListResponseDataItemsItem) SetUpdatedAt(updatedAt string) {
	i.UpdatedAt = updatedAt
	i.require(integrationListResponseDataItemsItemFieldUpdatedAt)
}

func (i *IntegrationListResponseDataItemsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationListResponseDataItemsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationListResponseDataItemsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntegrationListResponseDataItemsItem) MarshalJSON() ([]byte, error) {
	type embed IntegrationListResponseDataItemsItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IntegrationListResponseDataItemsItem) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Integration type
type IntegrationListResponseDataItemsItemType string

const (
	IntegrationListResponseDataItemsItemTypeSlack      IntegrationListResponseDataItemsItemType = "SLACK"
	IntegrationListResponseDataItemsItemTypeDiscord    IntegrationListResponseDataItemsItemType = "DISCORD"
	IntegrationListResponseDataItemsItemTypeSalesforce IntegrationListResponseDataItemsItemType = "SALESFORCE"
	IntegrationListResponseDataItemsItemTypeHubspot    IntegrationListResponseDataItemsItemType = "HUBSPOT"
	IntegrationListResponseDataItemsItemTypeOkta       IntegrationListResponseDataItemsItemType = "OKTA"
	IntegrationListResponseDataItemsItemTypeAuth0      IntegrationListResponseDataItemsItemType = "AUTH0"
)

func NewIntegrationListResponseDataItemsItemTypeFromString(s string) (IntegrationListResponseDataItemsItemType, error) {
	switch s {
	case "SLACK":
		return IntegrationListResponseDataItemsItemTypeSlack, nil
	case "DISCORD":
		return IntegrationListResponseDataItemsItemTypeDiscord, nil
	case "SALESFORCE":
		return IntegrationListResponseDataItemsItemTypeSalesforce, nil
	case "HUBSPOT":
		return IntegrationListResponseDataItemsItemTypeHubspot, nil
	case "OKTA":
		return IntegrationListResponseDataItemsItemTypeOkta, nil
	case "AUTH0":
		return IntegrationListResponseDataItemsItemTypeAuth0, nil
	}
	var t IntegrationListResponseDataItemsItemType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationListResponseDataItemsItemType) Ptr() *IntegrationListResponseDataItemsItemType {
	return &i
}

var (
	integrationResponseFieldData = big.NewInt(1 << 0)
)

type IntegrationResponse struct {
	Data *IntegrationResponseData `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IntegrationResponse) GetData() *IntegrationResponseData {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *IntegrationResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationResponse) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationResponse) SetData(data *IntegrationResponseData) {
	i.Data = data
	i.require(integrationResponseFieldData)
}

func (i *IntegrationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntegrationResponse) MarshalJSON() ([]byte, error) {
	type embed IntegrationResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IntegrationResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	integrationResponseDataFieldID           = big.NewInt(1 << 0)
	integrationResponseDataFieldType         = big.NewInt(1 << 1)
	integrationResponseDataFieldName         = big.NewInt(1 << 2)
	integrationResponseDataFieldActive       = big.NewInt(1 << 3)
	integrationResponseDataFieldExtendedData = big.NewInt(1 << 4)
	integrationResponseDataFieldCreatedAt    = big.NewInt(1 << 5)
	integrationResponseDataFieldUpdatedAt    = big.NewInt(1 << 6)
)

type IntegrationResponseData struct {
	ID string `json:"id" url:"id"`
	// Integration type
	Type IntegrationResponseDataType `json:"type" url:"type"`
	// Integration name
	Name string `json:"name" url:"name"`
	// Whether integration is active
	Active bool `json:"active" url:"active"`
	// Custom extended data
	ExtendedData map[string]interface{} `json:"extendedData,omitempty" url:"extendedData,omitempty"`
	// Integration creation timestamp
	CreatedAt string `json:"createdAt" url:"createdAt"`
	// Integration last update timestamp
	UpdatedAt string `json:"updatedAt" url:"updatedAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IntegrationResponseData) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *IntegrationResponseData) GetType() IntegrationResponseDataType {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *IntegrationResponseData) GetName() string {
	if i == nil {
		return ""
	}
	return i.Name
}

func (i *IntegrationResponseData) GetActive() bool {
	if i == nil {
		return false
	}
	return i.Active
}

func (i *IntegrationResponseData) GetExtendedData() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.ExtendedData
}

func (i *IntegrationResponseData) GetCreatedAt() string {
	if i == nil {
		return ""
	}
	return i.CreatedAt
}

func (i *IntegrationResponseData) GetUpdatedAt() string {
	if i == nil {
		return ""
	}
	return i.UpdatedAt
}

func (i *IntegrationResponseData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationResponseData) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationResponseData) SetID(id string) {
	i.ID = id
	i.require(integrationResponseDataFieldID)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationResponseData) SetType(type_ IntegrationResponseDataType) {
	i.Type = type_
	i.require(integrationResponseDataFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationResponseData) SetName(name string) {
	i.Name = name
	i.require(integrationResponseDataFieldName)
}

// SetActive sets the Active field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationResponseData) SetActive(active bool) {
	i.Active = active
	i.require(integrationResponseDataFieldActive)
}

// SetExtendedData sets the ExtendedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationResponseData) SetExtendedData(extendedData map[string]interface{}) {
	i.ExtendedData = extendedData
	i.require(integrationResponseDataFieldExtendedData)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationResponseData) SetCreatedAt(createdAt string) {
	i.CreatedAt = createdAt
	i.require(integrationResponseDataFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntegrationResponseData) SetUpdatedAt(updatedAt string) {
	i.UpdatedAt = updatedAt
	i.require(integrationResponseDataFieldUpdatedAt)
}

func (i *IntegrationResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationResponseData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntegrationResponseData) MarshalJSON() ([]byte, error) {
	type embed IntegrationResponseData
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IntegrationResponseData) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Integration type
type IntegrationResponseDataType string

const (
	IntegrationResponseDataTypeSlack      IntegrationResponseDataType = "SLACK"
	IntegrationResponseDataTypeDiscord    IntegrationResponseDataType = "DISCORD"
	IntegrationResponseDataTypeSalesforce IntegrationResponseDataType = "SALESFORCE"
	IntegrationResponseDataTypeHubspot    IntegrationResponseDataType = "HUBSPOT"
	IntegrationResponseDataTypeOkta       IntegrationResponseDataType = "OKTA"
	IntegrationResponseDataTypeAuth0      IntegrationResponseDataType = "AUTH0"
)

func NewIntegrationResponseDataTypeFromString(s string) (IntegrationResponseDataType, error) {
	switch s {
	case "SLACK":
		return IntegrationResponseDataTypeSlack, nil
	case "DISCORD":
		return IntegrationResponseDataTypeDiscord, nil
	case "SALESFORCE":
		return IntegrationResponseDataTypeSalesforce, nil
	case "HUBSPOT":
		return IntegrationResponseDataTypeHubspot, nil
	case "OKTA":
		return IntegrationResponseDataTypeOkta, nil
	case "AUTH0":
		return IntegrationResponseDataTypeAuth0, nil
	}
	var t IntegrationResponseDataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationResponseDataType) Ptr() *IntegrationResponseDataType {
	return &i
}

var (
	updateIntegrationsResponseFieldData = big.NewInt(1 << 0)
)

type UpdateIntegrationsResponse struct {
	Data *UpdateIntegrationsResponseData `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateIntegrationsResponse) GetData() *UpdateIntegrationsResponseData {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UpdateIntegrationsResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateIntegrationsResponse) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateIntegrationsResponse) SetData(data *UpdateIntegrationsResponseData) {
	u.Data = data
	u.require(updateIntegrationsResponseFieldData)
}

func (u *UpdateIntegrationsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateIntegrationsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateIntegrationsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateIntegrationsResponse) MarshalJSON() ([]byte, error) {
	type embed UpdateIntegrationsResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateIntegrationsResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	updateIntegrationsResponseDataFieldID           = big.NewInt(1 << 0)
	updateIntegrationsResponseDataFieldType         = big.NewInt(1 << 1)
	updateIntegrationsResponseDataFieldName         = big.NewInt(1 << 2)
	updateIntegrationsResponseDataFieldActive       = big.NewInt(1 << 3)
	updateIntegrationsResponseDataFieldExtendedData = big.NewInt(1 << 4)
	updateIntegrationsResponseDataFieldCreatedAt    = big.NewInt(1 << 5)
	updateIntegrationsResponseDataFieldUpdatedAt    = big.NewInt(1 << 6)
)

type UpdateIntegrationsResponseData struct {
	ID string `json:"id" url:"id"`
	// Integration type
	Type UpdateIntegrationsResponseDataType `json:"type" url:"type"`
	// Integration name
	Name string `json:"name" url:"name"`
	// Whether integration is active
	Active bool `json:"active" url:"active"`
	// Custom extended data
	ExtendedData map[string]interface{} `json:"extendedData,omitempty" url:"extendedData,omitempty"`
	// Integration creation timestamp
	CreatedAt string `json:"createdAt" url:"createdAt"`
	// Integration last update timestamp
	UpdatedAt string `json:"updatedAt" url:"updatedAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateIntegrationsResponseData) GetID() string {
	if u == nil {
		return ""
	}
	return u.ID
}

func (u *UpdateIntegrationsResponseData) GetType() UpdateIntegrationsResponseDataType {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UpdateIntegrationsResponseData) GetName() string {
	if u == nil {
		return ""
	}
	return u.Name
}

func (u *UpdateIntegrationsResponseData) GetActive() bool {
	if u == nil {
		return false
	}
	return u.Active
}

func (u *UpdateIntegrationsResponseData) GetExtendedData() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.ExtendedData
}

func (u *UpdateIntegrationsResponseData) GetCreatedAt() string {
	if u == nil {
		return ""
	}
	return u.CreatedAt
}

func (u *UpdateIntegrationsResponseData) GetUpdatedAt() string {
	if u == nil {
		return ""
	}
	return u.UpdatedAt
}

func (u *UpdateIntegrationsResponseData) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateIntegrationsResponseData) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateIntegrationsResponseData) SetID(id string) {
	u.ID = id
	u.require(updateIntegrationsResponseDataFieldID)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateIntegrationsResponseData) SetType(type_ UpdateIntegrationsResponseDataType) {
	u.Type = type_
	u.require(updateIntegrationsResponseDataFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateIntegrationsResponseData) SetName(name string) {
	u.Name = name
	u.require(updateIntegrationsResponseDataFieldName)
}

// SetActive sets the Active field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateIntegrationsResponseData) SetActive(active bool) {
	u.Active = active
	u.require(updateIntegrationsResponseDataFieldActive)
}

// SetExtendedData sets the ExtendedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateIntegrationsResponseData) SetExtendedData(extendedData map[string]interface{}) {
	u.ExtendedData = extendedData
	u.require(updateIntegrationsResponseDataFieldExtendedData)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateIntegrationsResponseData) SetCreatedAt(createdAt string) {
	u.CreatedAt = createdAt
	u.require(updateIntegrationsResponseDataFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateIntegrationsResponseData) SetUpdatedAt(updatedAt string) {
	u.UpdatedAt = updatedAt
	u.require(updateIntegrationsResponseDataFieldUpdatedAt)
}

func (u *UpdateIntegrationsResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateIntegrationsResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateIntegrationsResponseData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateIntegrationsResponseData) MarshalJSON() ([]byte, error) {
	type embed UpdateIntegrationsResponseData
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateIntegrationsResponseData) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Integration type
type UpdateIntegrationsResponseDataType string

const (
	UpdateIntegrationsResponseDataTypeSlack      UpdateIntegrationsResponseDataType = "SLACK"
	UpdateIntegrationsResponseDataTypeDiscord    UpdateIntegrationsResponseDataType = "DISCORD"
	UpdateIntegrationsResponseDataTypeSalesforce UpdateIntegrationsResponseDataType = "SALESFORCE"
	UpdateIntegrationsResponseDataTypeHubspot    UpdateIntegrationsResponseDataType = "HUBSPOT"
	UpdateIntegrationsResponseDataTypeOkta       UpdateIntegrationsResponseDataType = "OKTA"
	UpdateIntegrationsResponseDataTypeAuth0      UpdateIntegrationsResponseDataType = "AUTH0"
)

func NewUpdateIntegrationsResponseDataTypeFromString(s string) (UpdateIntegrationsResponseDataType, error) {
	switch s {
	case "SLACK":
		return UpdateIntegrationsResponseDataTypeSlack, nil
	case "DISCORD":
		return UpdateIntegrationsResponseDataTypeDiscord, nil
	case "SALESFORCE":
		return UpdateIntegrationsResponseDataTypeSalesforce, nil
	case "HUBSPOT":
		return UpdateIntegrationsResponseDataTypeHubspot, nil
	case "OKTA":
		return UpdateIntegrationsResponseDataTypeOkta, nil
	case "AUTH0":
		return UpdateIntegrationsResponseDataTypeAuth0, nil
	}
	var t UpdateIntegrationsResponseDataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateIntegrationsResponseDataType) Ptr() *UpdateIntegrationsResponseDataType {
	return &u
}

var (
	updateIntegrationsRequestFieldID           = big.NewInt(1 << 0)
	updateIntegrationsRequestFieldName         = big.NewInt(1 << 1)
	updateIntegrationsRequestFieldConfig       = big.NewInt(1 << 2)
	updateIntegrationsRequestFieldActive       = big.NewInt(1 << 3)
	updateIntegrationsRequestFieldExtendedData = big.NewInt(1 << 4)
)

type UpdateIntegrationsRequest struct {
	// Integration ID
	ID string `json:"-" url:"-"`
	// Integration name
	Name *string `json:"name,omitempty" url:"-"`
	// JSON configuration (merged with existing)
	Config map[string]interface{} `json:"config,omitempty" url:"-"`
	// Enable/disable integration
	Active *bool `json:"active,omitempty" url:"-"`
	// Custom extended data
	ExtendedData map[string]interface{} `json:"extendedData,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (u *UpdateIntegrationsRequest) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateIntegrationsRequest) SetID(id string) {
	u.ID = id
	u.require(updateIntegrationsRequestFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateIntegrationsRequest) SetName(name *string) {
	u.Name = name
	u.require(updateIntegrationsRequestFieldName)
}

// SetConfig sets the Config field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateIntegrationsRequest) SetConfig(config map[string]interface{}) {
	u.Config = config
	u.require(updateIntegrationsRequestFieldConfig)
}

// SetActive sets the Active field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateIntegrationsRequest) SetActive(active *bool) {
	u.Active = active
	u.require(updateIntegrationsRequestFieldActive)
}

// SetExtendedData sets the ExtendedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateIntegrationsRequest) SetExtendedData(extendedData map[string]interface{}) {
	u.ExtendedData = extendedData
	u.require(updateIntegrationsRequestFieldExtendedData)
}
