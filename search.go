// Code generated by Fern. DO NOT EDIT.

package foru_ms_sdk

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/foru-ms/go-sdk/internal"
	big "math/big"
)

var (
	searchSearchResponseFieldData = big.NewInt(1 << 0)
)

type SearchSearchResponse struct {
	Data *SearchSearchResponseData `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchSearchResponse) GetData() *SearchSearchResponseData {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *SearchSearchResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchSearchResponse) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSearchResponse) SetData(data *SearchSearchResponseData) {
	s.Data = data
	s.require(searchSearchResponseFieldData)
}

func (s *SearchSearchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchSearchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchSearchResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchSearchResponse) MarshalJSON() ([]byte, error) {
	type embed SearchSearchResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SearchSearchResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	searchSearchResponseDataFieldItems      = big.NewInt(1 << 0)
	searchSearchResponseDataFieldNextCursor = big.NewInt(1 << 1)
	searchSearchResponseDataFieldHasMore    = big.NewInt(1 << 2)
)

type SearchSearchResponseData struct {
	Items      []*SearchSearchResponseDataItemsItem `json:"items" url:"items"`
	NextCursor *string                              `json:"nextCursor,omitempty" url:"nextCursor,omitempty"`
	HasMore    bool                                 `json:"hasMore" url:"hasMore"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchSearchResponseData) GetItems() []*SearchSearchResponseDataItemsItem {
	if s == nil {
		return nil
	}
	return s.Items
}

func (s *SearchSearchResponseData) GetNextCursor() *string {
	if s == nil {
		return nil
	}
	return s.NextCursor
}

func (s *SearchSearchResponseData) GetHasMore() bool {
	if s == nil {
		return false
	}
	return s.HasMore
}

func (s *SearchSearchResponseData) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchSearchResponseData) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetItems sets the Items field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSearchResponseData) SetItems(items []*SearchSearchResponseDataItemsItem) {
	s.Items = items
	s.require(searchSearchResponseDataFieldItems)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSearchResponseData) SetNextCursor(nextCursor *string) {
	s.NextCursor = nextCursor
	s.require(searchSearchResponseDataFieldNextCursor)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSearchResponseData) SetHasMore(hasMore bool) {
	s.HasMore = hasMore
	s.require(searchSearchResponseDataFieldHasMore)
}

func (s *SearchSearchResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchSearchResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchSearchResponseData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchSearchResponseData) MarshalJSON() ([]byte, error) {
	type embed SearchSearchResponseData
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SearchSearchResponseData) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	searchSearchResponseDataItemsItemFieldType      = big.NewInt(1 << 0)
	searchSearchResponseDataItemsItemFieldID        = big.NewInt(1 << 1)
	searchSearchResponseDataItemsItemFieldTitle     = big.NewInt(1 << 2)
	searchSearchResponseDataItemsItemFieldBody      = big.NewInt(1 << 3)
	searchSearchResponseDataItemsItemFieldUsername  = big.NewInt(1 << 4)
	searchSearchResponseDataItemsItemFieldName      = big.NewInt(1 << 5)
	searchSearchResponseDataItemsItemFieldCreatedAt = big.NewInt(1 << 6)
)

type SearchSearchResponseDataItemsItem struct {
	Type      SearchSearchResponseDataItemsItemType `json:"type" url:"type"`
	ID        string                                `json:"id" url:"id"`
	Title     *string                               `json:"title,omitempty" url:"title,omitempty"`
	Body      *string                               `json:"body,omitempty" url:"body,omitempty"`
	Username  *string                               `json:"username,omitempty" url:"username,omitempty"`
	Name      *string                               `json:"name,omitempty" url:"name,omitempty"`
	CreatedAt *string                               `json:"createdAt,omitempty" url:"createdAt,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchSearchResponseDataItemsItem) GetType() SearchSearchResponseDataItemsItemType {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SearchSearchResponseDataItemsItem) GetID() string {
	if s == nil {
		return ""
	}
	return s.ID
}

func (s *SearchSearchResponseDataItemsItem) GetTitle() *string {
	if s == nil {
		return nil
	}
	return s.Title
}

func (s *SearchSearchResponseDataItemsItem) GetBody() *string {
	if s == nil {
		return nil
	}
	return s.Body
}

func (s *SearchSearchResponseDataItemsItem) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SearchSearchResponseDataItemsItem) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SearchSearchResponseDataItemsItem) GetCreatedAt() *string {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *SearchSearchResponseDataItemsItem) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchSearchResponseDataItemsItem) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSearchResponseDataItemsItem) SetType(type_ SearchSearchResponseDataItemsItemType) {
	s.Type = type_
	s.require(searchSearchResponseDataItemsItemFieldType)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSearchResponseDataItemsItem) SetID(id string) {
	s.ID = id
	s.require(searchSearchResponseDataItemsItemFieldID)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSearchResponseDataItemsItem) SetTitle(title *string) {
	s.Title = title
	s.require(searchSearchResponseDataItemsItemFieldTitle)
}

// SetBody sets the Body field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSearchResponseDataItemsItem) SetBody(body *string) {
	s.Body = body
	s.require(searchSearchResponseDataItemsItemFieldBody)
}

// SetUsername sets the Username field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSearchResponseDataItemsItem) SetUsername(username *string) {
	s.Username = username
	s.require(searchSearchResponseDataItemsItemFieldUsername)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSearchResponseDataItemsItem) SetName(name *string) {
	s.Name = name
	s.require(searchSearchResponseDataItemsItemFieldName)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSearchResponseDataItemsItem) SetCreatedAt(createdAt *string) {
	s.CreatedAt = createdAt
	s.require(searchSearchResponseDataItemsItemFieldCreatedAt)
}

func (s *SearchSearchResponseDataItemsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchSearchResponseDataItemsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchSearchResponseDataItemsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchSearchResponseDataItemsItem) MarshalJSON() ([]byte, error) {
	type embed SearchSearchResponseDataItemsItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SearchSearchResponseDataItemsItem) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchSearchResponseDataItemsItemType string

const (
	SearchSearchResponseDataItemsItemTypeThread SearchSearchResponseDataItemsItemType = "thread"
	SearchSearchResponseDataItemsItemTypePost   SearchSearchResponseDataItemsItemType = "post"
	SearchSearchResponseDataItemsItemTypeUser   SearchSearchResponseDataItemsItemType = "user"
	SearchSearchResponseDataItemsItemTypeTag    SearchSearchResponseDataItemsItemType = "tag"
)

func NewSearchSearchResponseDataItemsItemTypeFromString(s string) (SearchSearchResponseDataItemsItemType, error) {
	switch s {
	case "thread":
		return SearchSearchResponseDataItemsItemTypeThread, nil
	case "post":
		return SearchSearchResponseDataItemsItemTypePost, nil
	case "user":
		return SearchSearchResponseDataItemsItemTypeUser, nil
	case "tag":
		return SearchSearchResponseDataItemsItemTypeTag, nil
	}
	var t SearchSearchResponseDataItemsItemType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchSearchResponseDataItemsItemType) Ptr() *SearchSearchResponseDataItemsItemType {
	return &s
}
